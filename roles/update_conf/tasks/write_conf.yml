# write_conf
# receives variables:
#    application_name
#    puppet_config_name
#    config: config file path relative to a server or container
#    section_name: "{{ item.section_name }}"
#    parameter_name: "{{ item.parameter_name }}"
#    local_ip: "{{ local_ip_address }}"

# notes:
# get existing password for service:
# hiera -c /etc/puppet/hiera.yaml "cinder::db::mysql::password"
#
# root:
# /bin/hiera -c /etc/puppet/hiera.yaml "mysql::server::root_password"
#
#
#
# docker exec -it  galera-bundle-docker-0 mysql -u root --password="tbebgne63M"
#

- name: "{{ application_name }}: set puppet-generated file location"
  set_fact:
      config_file: "{{ openstack_controller_puppet_generated }}/{{ puppet_config_name }}{{ config }}"
  when: puppet_config_name is defined

- name: "{{ application_name }}: set non-puppet-generated file location"
  set_fact:
      config_file: "{{ config }}"
  when: puppet_config_name is not defined

- name: "{{ application_name }}: set location for account_per_controller.cnf"
  set_fact:
      account_per_controller: "{{ openstack_controller_puppet_generated }}/{{ puppet_config_name }}/etc/my.cnf.d/account_per_controller.cnf"

- name: "{{ application_name }}: read current SQLAlchemy URL for section"
  shell: |
      crudini --get {{ config_file }}  {{ section_name}}  {{ parameter_name }}
  register: command_output

- name: "{{ application_name }}: get URL"
  set_fact:
    existing_url: "{{ command_output.stdout }}"

- name: "{{ application_name }}: find a container image we can use to run commands"
  shell: |
    {{ container_cli }} ps --format \{\{'.Image'\}\} --filter name={{ containers[0] }}
  register: command_output

- name: "{{ application_name }}: set container image name fact"
  set_fact:
    container_image: "{{ command_output.stdout_lines[0] }}"
    script_runner: "{{ container_cli }} run -i -u root -v '{{ openstack_controller_puppet_generated }}/{{ puppet_config_name }}:{{ openstack_controller_puppet_generated }}/{{ puppet_config_name }}' {{ command_output.stdout_lines[0] }}"

- name: "{{ application_name }}: read current URL and split"
  shell: "{{ script_content }}"
  vars:
    script_content: |
      cat << EOF | {{ script_runner }} python
      from __future__ import print_function
      from sqlalchemy.engine import url
      u = url.make_url('{{ existing_url }}')
      print("\n".join(
          [u.get_backend_name() or '', u.username or '', u.host or '',
           u.database, u.query.get("read_default_group", '')]
      ))
      EOF
  register: command_output

- name: "{{ application_name }}: set existing database URL components"
  set_fact:
    db_backend: "{{ command_output.stdout_lines[0] }}"
    db_user: "{{ command_output.stdout_lines[1] }}"
    db_host: "{{ command_output.stdout_lines[2] }}"
    db_name: "{{ command_output.stdout_lines[3] }}"
    read_group: "{{ command_output.stdout_lines[4] }}"

- name: "{{ application_name }}: did we make a password yet"
  shell: "{{ script_runner }} crudini --get {{ account_per_controller }} {{ application_name }} password"
  register: mysql_password_file_output
  ignore_errors: yes

- name: "{{ application_name }}: register password fact from existing"
  set_fact:
    mysql_generated_password: "{{ mysql_password_file_output.stdout_lines[0] }}"
  when: mysql_password_file_output.rc == 0

- name: "{{ application_name }}: create new password if not exists"
  shell: "{{ mysql_cli }} 'SELECT sha2(rand(), 256)'"
  register: mysql_password_generate_output
#  when: mysql_password_file_output.rc != 0

- name: "{{ application_name }}: register password fact from generated"
  set_fact:
    mysql_generated_password: "{{ mysql_password_generate_output.stdout_lines[0] }}"
#  when: mysql_password_file_output.rc != 0

- name: "{{ application_name }}: determine new user name, derived from controller hostname"
  shell: |
      HOSTNAME=`hostname`
      CONTROLLER_IDX=`echo ${HOSTNAME} | sed 's/overcloud\|controller\|-//g'`
      NEW_USER="{{ db_user }}${CONTROLLER_IDX}"
      echo "${NEW_USER}"
  register: username_output

- name: "{{ application_name }}: set username password facts"
  set_fact:
    db_apc_username: "{{ username_output.stdout_lines[0] }}"
    db_apc_password: "{{ mysql_generated_password }}"


- name: "{{ application_name }}: write data to account_per_controller.cnf"
  shell: "{{ script_content }}"
  vars:
    script_content: |
      cat << EOF | {{ script_runner }} bash
          crudini --set {{ account_per_controller }} {{ application_name }} user {{ db_apc_username }}
          crudini --set {{ account_per_controller }} {{ application_name }} password {{ db_apc_password }}
          crudini --set {{ account_per_controller }} {{ application_name }} host {{ local_ip_address }}
          crudini --set {{ account_per_controller }} {{ application_name }} port 3307
          crudini --set {{ account_per_controller }} {{ application_name }} bind_address {{ local_ip_address }}
      EOF